import sqlite3
import pandas as pd
import streamlit as st
import plotly.express as px

# Page config
st.set_page_config(page_title="Flipkart Price Tracker", layout="wide")

st.title("ðŸ“ˆ Flipkart Product Price Tracker")

# Connect to DB and load data
conn = sqlite3.connect("limited_product_prices.db")
query = "SELECT * FROM limited_product_price_history"
df = pd.read_sql_query(query, conn)

# Rename columns
df.columns = ["id", "file_name", "timestamp", "price", "rating", "url"]

# Normalize timestamp
df["timestamp"] = pd.to_datetime(df["timestamp"].str.replace("_", " "), errors="coerce")

# Extract product name fallback
df["product"] = df["file_name"]
df.loc[df["product"].isnull() | (df["product"] == ""), "product"] = df["url"].apply(
    lambda x: x.split("/")[3] if isinstance(x, str) and x.startswith("http") else "Unknown"
)

# Sidebar: Multi-product select (default 1st product)
product_list = sorted(df["product"].unique())
selected_products = st.sidebar.multiselect("Select products to compare", product_list, default=product_list[:1])

if not selected_products:
    st.warning("Please select at least one product.")
    st.stop()

# Sidebar: Date range filter across all selected products
min_date = df[df["product"].isin(selected_products)]["timestamp"].min().date()
max_date = df[df["product"].isin(selected_products)]["timestamp"].max().date()
start_date, end_date = st.sidebar.date_input("Select date range", [min_date, max_date], min_value=min_date, max_value=max_date)

# Sidebar: Price alert for each product (simple single alert threshold)
alert_price = st.sidebar.number_input("Set price alert (notify if price below)", min_value=0, value=0, step=1)

# Filter data by selected products and date range
filtered_df = df[
    (df["product"].isin(selected_products)) &
    (df["timestamp"].dt.date >= start_date) &
    (df["timestamp"].dt.date <= end_date)
]

st.markdown(f"## ðŸ“Œ Currently Selected Products: `{', '.join(selected_products)}`")
st.markdown(f"### Date range: {start_date} to {end_date}")

if filtered_df.empty:
    st.warning("No price data available for the selected product(s) and date range.")
    st.stop()

# Plot comparison chart
fig = px.line(title="Price Trends Comparison")
for product in selected_products:
    product_df = filtered_df[filtered_df["product"] == product].sort_values("timestamp")
    fig.add_scatter(
        x=product_df["timestamp"],
        y=product_df["price"],
        mode='lines+markers',
        name=product
    )
fig.update_layout(xaxis_title="Timestamp", yaxis_title="Price (INR)")
st.plotly_chart(fig, use_container_width=True)

# Show detailed stats and alerts per product
for product in selected_products:
    st.markdown(f"### ðŸ“Š Price Summary for `{product}`")
    product_df = filtered_df[filtered_df["product"] == product].sort_values("timestamp")
    if product_df.empty:
        st.write("No data for this product in the selected date range.")
        continue

    max_price = product_df["price"].max()
    min_price = product_df["price"].min()
    avg_price = product_df["price"].mean()
    current_price = product_df["price"].iloc[-1]

    st.write(f"**Max Price:** â‚¹{max_price:.2f}")
    st.write(f"**Min Price:** â‚¹{min_price:.2f}")
    st.write(f"**Average Price:** â‚¹{avg_price:.2f}")
    st.write(f"**Current Price (Latest):** â‚¹{current_price:.2f}")

    if len(product_df) >= 2:
        previous_price = product_df["price"].iloc[-2]
        price_diff = current_price - previous_price
        pct_change = (price_diff / previous_price) * 100 if previous_price else 0
        if price_diff > 0:
            st.warning(f"ðŸ“ˆ Price Increased by â‚¹{price_diff:.2f} ({pct_change:.2f}%) since last update")
        elif price_diff < 0:
            st.success(f"ðŸ“‰ Price Dropped by â‚¹{abs(price_diff):.2f} ({abs(pct_change):.2f}%) since last update")
        else:
            st.info("Price remained the same since last update")

    # Price alert
    if alert_price > 0 and current_price < alert_price:
        st.success(f"ðŸš¨ Price Alert! Current price â‚¹{current_price:.2f} is below your alert threshold â‚¹{alert_price}")

    # Download filtered product data as CSV
    csv = product_df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label=f"Download {product} Price History CSV",
        data=csv,
        file_name=f"{product}_price_history.csv",
        mime="text/csv",
        key=f"download_{product}"
    )

# Optional: Show full raw data table for all selected products
if st.checkbox("Show raw data table for selected products"):
    st.write(filtered_df.sort_values(["product", "timestamp"]))
